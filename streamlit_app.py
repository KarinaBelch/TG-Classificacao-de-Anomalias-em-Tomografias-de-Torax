# -*- coding: utf-8 -*-
"""streamlit_app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1J3vOtbYuhL-M4B1awIJW6kBkTZM2Vc1t
"""

# @title Importando bibliotecas

import streamlit as st
import numpy as np
import os
import pydicom
import gdown
import zipfile
import zipfile
import shutil
from tensorflow.keras.models import load_model
from PIL import Image

# @title Par√¢metros

# Listar arquivos .dcm
dicom_files = []

# Resultados armazenados em lista
resultados = []

# @title Fun√ß√µes

# Fun√ß√£o para obter os arquivos DICOM que est√£o no arquivo zipado enviado pelo usu√°rio
def funcObterArquivoDicom(dicom_dir):
  for root, dirs, files in os.walk(dicom_dir):
      for file in files:
          if file.endswith(".dcm"):
              dicom_files.append(os.path.join(root, file))

  print("Arquivos DICOM encontrados:", len(dicom_files))

  return dicom_files

# Fun√ß√£o para ordenar as fatias do arquivo DICOM
def funcOrdenarFatias(dicom_files):
  # Ordenar por InstanceNumber (ordem axial)
  slices = [pydicom.dcmread(f) for f in dicom_files]
  slices = [s for s in slices if hasattr(s, 'InstanceNumber')]
  slices.sort(key=lambda s: s.InstanceNumber)

  # Converter para volume 3D
  volume = np.stack([s.pixel_array for s in slices])

  print("Volume 3D:", volume.shape)  # (profundidade, altura, largura)

  return slices, volume

# @title Layout

# # Titulo da p√°gina
st.set_page_config(page_title='Trabalho de Gradua√ß√£o', page_icon='ü•º', layout='wide')
st.title('Classifica√ß√£o de Anomalias em TC de T√≥rax')
st.info('Trabalho de Gradua√ß√£o referente ao curso de Engenharia Biom√©dica da Universidade Federal do ABC | Identifica√ß√£o e localiza√ß√£o de anomalias causadas por c√¢ncer de pulm√£o, em tomografias de t√≥rax, utilizando intelig√™ncia artifical')
#
# Menu Lateral
st.sidebar.header("Menu")
st.sidebar.caption("Leitura de arquivos DICOM.")
#
# # Upload do arquivo
uploaded_zip = st.file_uploader(label='Upload your DICOM file:', type="zip")

# @title Processamento dos arquivos DICOM

# Ajuste para o seu modelo
IMG_SIZE = 128
MODEL_ID = "1zfggM4S9HxRphPcGN2dCrWWswYr2kEMV"  # coloque aqui o ID do Google Drive
MODEL_PATH = "classifier.h5"
MODEL_URL = f"https://drive.google.com/uc?id={MODEL_ID}"

# Baixa o modelo se n√£o existir
if not os.path.exists(MODEL_PATH):
    with st.spinner("Baixando o modelo..."):
        gdown.download(MODEL_URL, MODEL_PATH, quiet=False)

# Carrega o modelo treinado
modelo = load_model('classifier.h5')

if uploaded_zip:
    temp_dir = "temp_upload"

    # Limpar e criar diret√≥rio tempor√°rio
    if os.path.exists(temp_dir):
        shutil.rmtree(temp_dir)
    os.makedirs(temp_dir)

    # Salvar arquivo zip
    zip_path = os.path.join(temp_dir, "uploaded.zip")
    with open(zip_path, "wb") as f:
        f.write(uploaded_zip.getbuffer())

    # Extrair arquivos do zip
    with zipfile.ZipFile(zip_path, "r") as zip_ref:
        zip_ref.extractall(temp_dir)

    # Chamando a fun√ß√£o para obter os arquivos DICOM do arquivo zipado
    dicom_files = funcObterArquivoDicom(temp_dir)

    st.write("Arquivos DICOM encontrados:", len(dicom_files))

    # Ler e ordenar as fatias
    slices, volume = funcOrdenarFatias(dicom_files)

    for i in range(len(slices)):
        img_array = slices[i].pixel_array  # Se slices[i] for objeto DICOM
        # Ou, se for array numpy direto:
        # img_array = slices[i]
        
        # img_array vem do DICOM ou do seu dataset
        img_pil = Image.fromarray(img_array)
        img_resized = img_pil.resize((128, 128))
        img_array = np.array(img_resized)
        
        img_array = np.expand_dims(img_array, axis=-1)  # canal
        img_array = np.expand_dims(img_array, axis=0)   # batch
        
        img_array = img_array.astype('float32') / 255.0
        
        pred = modelo.predict(img_array)
        
        resultados.append((i, pred))
        print(f"Slice {i} - Predi√ß√£o: {pred}")
        
        pred_class = "Doente" if pred_prob > 0.5 else "Saud√°vel"

        # Mostrar imagem e resultado
        st.image(img_resized, caption=f"Imagem: {os.path.basename(dicom_path)}")
        st.write(f"Predi√ß√£o: {pred_class} ({pred_prob:.3f})")
        st.markdown("---")
