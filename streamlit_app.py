# -*- coding: utf-8 -*-
"""streamlit_app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1J3vOtbYuhL-M4B1awIJW6kBkTZM2Vc1t
"""

# @title Importando bibliotecas

import streamlit as st
import numpy as np
import os
import pydicom
import gdown
import zipfile
import zipfile
import shutil
from tensorflow.keras.models import load_model
from PIL import Image

# @title Par칙metros

# Listar arquivos .dcm
dicom_files = []

# Resultados armazenados em lista
resultados = []

# Ajuste para o modelo
IMG_SIZE = 128
MODEL_ID = "1zfggM4S9HxRphPcGN2dCrWWswYr2kEMV"  # ID do Google Drive
MODEL_PATH = "classifier.h5"
MODEL_URL = f"https://drive.google.com/uc?id={MODEL_ID}"

# Layout das colunas
NUM_COLS = 3

# @title Fun칞칫es

# Fun칞칚o para obter os arquivos DICOM que est칚o no arquivo zipado enviado pelo usu치rio
def funcObterArquivoDicom(dicom_dir):
  for root, dirs, files in os.walk(dicom_dir):
      for file in files:
          if file.endswith(".dcm"):
              dicom_files.append(os.path.join(root, file))

  return dicom_files

# Fun칞칚o para ordenar as fatias do arquivo DICOM
def funcOrdenarFatias(dicom_files):
  # Ordenar por InstanceNumber (ordem axial)
  slices = [pydicom.dcmread(f) for f in dicom_files]
  slices = [s for s in slices if hasattr(s, 'InstanceNumber')]
  slices.sort(key=lambda s: s.InstanceNumber)

  # Converter para volume 3D
  volume = np.stack([s.pixel_array for s in slices])

  # st.write("Volume 3D:", volume.shape)  # (profundidade, altura, largura)

  return slices, volume

# @title Layout

# # Titulo da p치gina
st.set_page_config(page_title='Trabalho de Gradua칞칚o', page_icon='游봎', layout='wide')
st.title('Classifica칞칚o de Anomalias em TC de T칩rax')
st.info('Identifica칞칚o e localiza칞칚o de anomalias causadas por c칙ncer de pulm칚o, em tomografias de t칩rax, utilizando intelig칡ncia artifical | Trabalho de Gradua칞칚o referente ao curso de Engenharia Biom칠dica da Universidade Federal do ABC')
#
# Menu Lateral
st.sidebar.header("Menu")
st.sidebar.caption("Leitura de arquivos DICOM.")
#
# # Upload do arquivo
uploaded_zip = st.file_uploader(label='Upload your DICOM file:', type="zip")

# @title Processamento dos arquivos DICOM


# Baixa o modelo se n칚o existir
if not os.path.exists(MODEL_PATH):
    with st.spinner("Baixando o modelo..."):
        gdown.download(MODEL_URL, MODEL_PATH, quiet=False)

# Carrega o modelo treinado
modelo = load_model('classifier.h5')

if uploaded_zip:
    temp_dir = "temp_upload"

    # Limpar e criar diret칩rio tempor치rio
    if os.path.exists(temp_dir):
        shutil.rmtree(temp_dir)
    os.makedirs(temp_dir)

    # Salvar arquivo zip
    zip_path = os.path.join(temp_dir, "uploaded.zip")
    with open(zip_path, "wb") as f:
        f.write(uploaded_zip.getbuffer())

    # Extrair arquivos do zip
    with zipfile.ZipFile(zip_path, "r") as zip_ref:
        zip_ref.extractall(temp_dir)

    # Filtros
    if 'filtro' not in st.session_state:
        st.session_state.filtro = "Todos"

    # Chamando a fun칞칚o para obter os arquivos DICOM do arquivo zipado
    dicom_files = funcObterArquivoDicom(temp_dir)

    # Ler e ordenar as fatias
    slices, volume = funcOrdenarFatias(dicom_files)

    # Passo 2: bot칫es para filtrar
    if 'filtro' not in st.session_state:
        st.session_state.filtro = "Todos"

    col1, col2 = st.columns(2)

    with col1:
      flex_filtro = st.container(border=True, gap="small", height=175)

      flex_filtro.subheader("Filtro")

      flex_botoes = flex_filtro.container(horizontal=True, horizontal_alignment="left")

      if flex_botoes.button("Todos", key="btn_todos"):
          st.session_state.filtro = "Todos"
      elif flex_botoes.button("Apenas C칙ncer", key="btn_cancer"):
          st.session_state.filtro = "Apenas C칙ncer"
      elif flex_botoes.button("Apenas Saud치vel", key="btn_saudavel"):
          st.session_state.filtro = "Apenas Saud치vel"

      flex_filtro.write(f"Filtro ativo: {st.session_state.filtro}")


    # Processando os dados
    for dicom_path in dicom_files:
        ds = pydicom.dcmread(dicom_path)
        img = ds.pixel_array.astype(np.float32)

        img_pil = Image.fromarray(img)
        img_resized = img_pil.resize((IMG_SIZE, IMG_SIZE))
        img_to_show = img_resized.convert("L")

        img_array = np.array(img_resized)
        img_array = np.expand_dims(img_array, axis=-1)
        img_array = np.expand_dims(img_array, axis=0)
        img_array = img_array / 255.0

        pred = modelo.predict(img_array)
        pred_prob = float(pred[0][0])
        pred_class = "C칙ncer" if pred_prob > 0.5 else "Saud치vel"

        resultados.append({
            "img": img_to_show,
            "pred_class": pred_class,
            "pred_prob": pred_prob,
            "filename": os.path.basename(dicom_path)
        })

    num_cancer = [r for r in resultados if r['pred_class'] == 'C칙ncer']
    num_saudavel = [r for r in resultados if r['pred_class'] == 'Saud치vel']

    with col2:
      flex_dados = st.container(border=True, gap="small", height=175)
        
      flex_dados.write("Dados")
      flex_dados.write(f"Arquivos DICOM encontrados: {len(dicom_files)}")
      flex_dados.write(f"Slices detectados com c칙ncer: {len(num_cancer)}")
      flex_dados.write(f"Slices detectados como saud치vel: {len(num_saudavel)}")

    # Exibir imagens filtradas lado a lado

    filtrado = []
    if st.session_state.filtro == "Todos":
        filtrado = resultados
    elif st.session_state.filtro == "Apenas C칙ncer":
        filtrado = num_cancer
    else:
        filtrado = num_saudavel

    for i in range(0, len(filtrado), NUM_COLS):
        cols = st.columns(min(NUM_COLS, len(filtrado) - i))
        batch = filtrado[i:i+NUM_COLS]

        for j, item in enumerate(batch):
            with cols[j]:
                st.image(item["img"], caption=f"{item['filename']}")
                st.write(f"Predi칞칚o: {item['pred_class']} ({item['pred_prob']:.3f})")
