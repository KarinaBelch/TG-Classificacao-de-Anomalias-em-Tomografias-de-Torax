# -*- coding: utf-8 -*-
"""streamlit_app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1J3vOtbYuhL-M4B1awIJW6kBkTZM2Vc1t
"""

# @title Importando bibliotecas

import streamlit as st
import numpy as np
import os
import pydicom
import gdown
import zipfile
import shutil
import tensorflow as tf
#from tensorflow.keras.models import load_model
from PIL import Image

import cv2
from skimage import measure
from skimage.segmentation import clear_border
from scipy.ndimage import binary_fill_holes


# @title Par√¢metros

# Listar arquivos .dcm
dicom_files = []

# Resultados armazenados em lista
resultados = []

# Ajuste para o modelo
IMG_SIZE = 128
MODEL_ID = "1zfggM4S9HxRphPcGN2dCrWWswYr2kEMV"  # ID do Google Drive
MODEL_PATH = "classifier.h5"
MODEL_URL = f"https://drive.google.com/uc?id={MODEL_ID}"

# Layout das colunas
NUM_COLS = 3



# ==========================
# Fun√ß√µes auxiliares
# ==========================

def funcObterArquivoDicom(dicom_dir):
    dicom_files = []
    for root, dirs, files in os.walk(dicom_dir):
        for file in files:
            if file.endswith(".dcm"):
                dicom_files.append(os.path.join(root, file))
    return dicom_files


def funcOrdenarFatias(dicom_files):
    # Ordenar por InstanceNumber (ordem axial)
    slices = [pydicom.dcmread(f) for f in dicom_files]
    slices = [s for s in slices if hasattr(s, 'InstanceNumber')]
    slices.sort(key=lambda s: s.InstanceNumber)
    volume = np.stack([s.pixel_array for s in slices])
    return slices, volume


# ==========================
# Segmenta√ß√£o Pulmonar (mesma do treino)
# ==========================
def segment_lung_mask(image_hu, fill_lung_structures=True):
    """
    Segmenta os pulm√µes de uma imagem de TC em HU.
    """
    binary_image = np.array(image_hu < -320, dtype=np.int8)
    labels = measure.label(binary_image)
    background_label = labels[0, 0]
    binary_image[labels == background_label] = 0

    if fill_lung_structures:
        binary_image = binary_fill_holes(binary_image)

    binary_image = clear_border(binary_image)
    labels = measure.label(binary_image)
    regions = measure.regionprops(labels)
    regions.sort(key=lambda x: x.area, reverse=True)

    final_mask = np.zeros_like(binary_image, dtype=bool)
    for region in regions[:2]:
        final_mask[labels == region.label] = True

    # Remove bordas para evitar artefatos
    final_mask[:5, :] = False
    final_mask[-5:, :] = False
    final_mask[:, :5] = False
    final_mask[:, -5:] = False

    return final_mask


def preprocess_image_from_ds(ds):
    """
    Pr√©-processamento da imagem DICOM para predi√ß√£o:
    - Convers√£o para HU
    - Segmenta√ß√£o do pulm√£o
    - Normaliza√ß√£o [0,1]
    - Redimensionamento
    """
    # HU
    image = ds.pixel_array.astype(np.int16)
    intercept = ds.RescaleIntercept if 'RescaleIntercept' in ds else -1024
    slope = ds.RescaleSlope if 'RescaleSlope' in ds else 1
    image = slope * image + intercept

    # Segmenta√ß√£o pulmonar
    lung_mask = segment_lung_mask(image, fill_lung_structures=True)
    image_segmented = image.copy()
    image_segmented[~lung_mask] = np.min(image)

    # Normaliza√ß√£o [0,1]
    image_segmented = (image_segmented - np.min(image_segmented)) / (np.max(image_segmented) - np.min(image_segmented))

    # Redimensionamento
    image_resized = cv2.resize(image_segmented, (IMG_SIZE, IMG_SIZE))

    return image_resized


def predict_single_dicom(dicom_path, model):
    ds = pydicom.dcmread(dicom_path)
    img_preprocessed = preprocess_image_from_ds(ds)
    img_array = np.expand_dims(img_preprocessed, axis=(0, -1))
    prob = model.predict(img_array, verbose=0)[0][0]
    pred_class = "C√¢ncer" if prob > 0.5 else "Saud√°vel"
    img_to_show = Image.fromarray((img_preprocessed * 255).astype(np.uint8))
    return prob, pred_class, img_to_show


# ==========================
# Layout Streamlit
# ==========================
st.set_page_config(page_title='Trabalho de Gradua√ß√£o', page_icon='ü•º', layout='wide')
st.title('Classifica√ß√£o de Anomalias em TC de T√≥rax')
st.info('Identifica√ß√£o e localiza√ß√£o de anomalias causadas por c√¢ncer de pulm√£o, em tomografias de t√≥rax, utilizando intelig√™ncia artificial | Trabalho de Gradua√ß√£o referente ao curso de Engenharia Biom√©dica da UFABC')

st.sidebar.header("Menu")
st.sidebar.caption("Leitura de arquivos DICOM.")

uploaded_zip = st.file_uploader(label='Upload seu arquivo .zip com DICOMs', type="zip")

# ==========================
# Carrega modelo treinado
# ==========================
if not os.path.exists(MODEL_PATH):
    with st.spinner("Baixando o modelo..."):
        gdown.download(MODEL_URL, MODEL_PATH, quiet=False)

modelo = tf.keras.models.load_model(MODEL_PATH)

# ==========================
# Processamento do ZIP
# ==========================
if uploaded_zip:
    temp_dir = "temp_upload"

    # Limpar diret√≥rio tempor√°rio
    if os.path.exists(temp_dir):
        shutil.rmtree(temp_dir)
    os.makedirs(temp_dir)

    # Salvar zip tempor√°rio
    zip_path = os.path.join(temp_dir, "uploaded.zip")
    with open(zip_path, "wb") as f:
        f.write(uploaded_zip.getbuffer())

    # Extrair
    with zipfile.ZipFile(zip_path, "r") as zip_ref:
        zip_ref.extractall(temp_dir)

    dicom_files = funcObterArquivoDicom(temp_dir)
    slices, volume = funcOrdenarFatias(dicom_files)

    # Filtro lateral
    if 'filtro' not in st.session_state:
        st.session_state.filtro = "Todos"

    col1, col2 = st.columns(2)

    with col1:
        flex_filtro = st.container(border=True, gap="small", height=200)
        flex_filtro.subheader("Filtro", divider=True)
        flex_botoes = flex_filtro.container(horizontal=True, horizontal_alignment="left")

        if flex_botoes.button("Todos", key="btn_todos"):
            st.session_state.filtro = "Todos"
        if flex_botoes.button("Apenas C√¢ncer", key="btn_cancer"):
            st.session_state.filtro = "Apenas C√¢ncer"
        if flex_botoes.button("Apenas Saud√°vel", key="btn_saudavel"):
            st.session_state.filtro = "Apenas Saud√°vel"

        flex_filtro.write(f"Filtro ativo: {st.session_state.filtro}")

    # Predi√ß√£o
    resultados = []
    for dicom_path in dicom_files:
        try:
            prob, pred_class, img_to_show = predict_single_dicom(dicom_path, modelo)
            resultados.append({
                "img": img_to_show,
                "pred_class": pred_class,
                "pred_prob": prob,
                "filename": os.path.basename(dicom_path)
            })
        except Exception as e:
            st.error(f"Erro ao processar {os.path.basename(dicom_path)}: {e}")

    # Contagem
    num_cancer = [r for r in resultados if r['pred_class'] == 'C√¢ncer']
    num_saudavel = [r for r in resultados if r['pred_class'] == 'Saud√°vel']

    with col2:
        flex_dados = st.container(border=True, gap="small", height=200)
        flex_dados.subheader("Dados", divider=True)
        flex_dados.write(f"Arquivos DICOM encontrados: {len(dicom_files)}")
        flex_dados.write(f"Slices detectados com c√¢ncer: {len(num_cancer)}")
        flex_dados.write(f"Slices detectados como saud√°vel: {len(num_saudavel)}")

    # Exibi√ß√£o dos resultados filtrados
    if st.session_state.filtro == "Todos":
        filtrado = resultados
    elif st.session_state.filtro == "Apenas C√¢ncer":
        filtrado = num_cancer
    else:
        filtrado = num_saudavel

    st.subheader("Resultados")
    for i in range(0, len(filtrado), NUM_COLS):
        cols = st.columns(min(NUM_COLS, len(filtrado) - i))
        batch = filtrado[i:i+NUM_COLS]

        for j, item in enumerate(batch):
            with cols[j]:
                st.image(item["img"], caption=f"{item['filename']}")
                st.write(f"Predi√ß√£o: {item['pred_class']} ({item['pred_prob']:.3f})")
