# -*- coding: utf-8 -*-
"""streamlit_app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1J3vOtbYuhL-M4B1awIJW6kBkTZM2Vc1t
"""

# @title Importando bibliotecas

import streamlit as st
from tensorflow.keras.models import load_model
import numpy as np
import os
import zipfile
import gdown
import pydicom
import shutil

# @title Par√¢metros

# Listar arquivos .dcm
dicom_files = []

# Resultados armazenados em lista
resultados = []

# @title Fun√ß√µes

# Fun√ß√£o para obter os arquivos DICOM que est√£o no arquivo zipado enviado pelo usu√°rio
def funcObterArquivoDicom(dicom_dir):
  for root, dirs, files in os.walk(dicom_dir):
      for file in files:
          if file.endswith(".dcm"):
              dicom_files.append(os.path.join(root, file))

  print("Arquivos DICOM encontrados:", len(dicom_files))

  return dicom_files

# Fun√ß√£o para ordenar as fatias do arquivo DICOM
def funcOrdenarFatias(dicom_files):
  # Ordenar por InstanceNumber (ordem axial)
  slices = [pydicom.dcmread(f) for f in dicom_files]
  slices = [s for s in slices if hasattr(s, 'InstanceNumber')]
  slices.sort(key=lambda s: s.InstanceNumber)

  # Converter para volume 3D
  volume = np.stack([s.pixel_array for s in slices])

  print("Volume 3D:", volume.shape)  # (profundidade, altura, largura)

  return slices, volume

# @title Layout

# Titulo da p√°gina
st.set_page_config(page_title='Trabalho de Gradua√ß√£o', page_icon='ü•º', layout='wide')
st.title('Classifica√ß√£o de Anomalias em TC de T√≥rax')
st.info('Trabalho de Gradua√ß√£o referente ao curso de Engenharia Biom√©dica da Universidade Federal do ABC | Identifica√ß√£o e localiza√ß√£o de anomalias causadas por c√¢ncer de pulm√£o, em tomografias de t√≥rax, utilizando intelig√™ncia artifical')
#
# Menu Lateral
st.sidebar.header("Menu")
st.sidebar.caption("Leitura de arquivos DICOM.")
#
# # Upload do arquivo
uploaded_zip = st.file_uploader(label='Upload your DICOM file:', type="zip")

# @title Processamento dos arquivos DICOM

model_path = "modelo_treinado.h5"

if not os.path.exists(model_path):
    url = "https://drive.google.com/uc?id=11oFWS9_ckKVAhSlbjcRglDfU6IyBGcjM"
    gdown.download(url, model_path, quiet=False)

# Carregando o modelo
modelo = load_model(model_path)  # Nome do arquivo dentro do zip

if uploaded_zip:
    temp_dir = "temp_upload"

    # Limpar e criar diret√≥rio tempor√°rio
    if os.path.exists(temp_dir):
        shutil.rmtree(temp_dir)
    os.makedirs(temp_dir)

    # Salvar arquivo zip
    zip_path = os.path.join(temp_dir, "uploaded.zip")
    with open(zip_path, "wb") as f:
        f.write(uploaded_zip.getbuffer())

    # Extrair arquivos do zip
    with zipfile.ZipFile(zip_path, "r") as zip_ref:
        zip_ref.extractall(temp_dir)

    # Chamando a fun√ß√£o para obter os arquivos DICOM do arquivo zipado
    dicom_files = funcObterArquivoDicom(temp_dir)

    st.write("Arquivos DICOM encontrados:", len(dicom_files))

    # Ler e ordenar as fatias
    slices, volume = funcOrdenarFatias(dicom_files)

    for i in range(len(slices)):
      img_array = slices[i]  # pega a fatia
      # Pr√©-processamento exemplo: redimensionar, normalizar etc. (ajuste conforme seu modelo)
      img_array = np.expand_dims(img_array, axis=-1)  # adiciona canal se necess√°rio
      img_array = img_array / 255.0  # normaliza
      img_array = np.expand_dims(img_array, axis=0)  # adiciona batch dimension

      pred = modelo.predict(img_array)
      resultados.append((i, pred))
      print(f"Slice {i} - Predi√ß√£o: {pred}")